// constraint-cache.h
//
// Constraint cache checks that the constraints in the cache are a subset
// of the incoming constraints in the store. This enables us to check
// if the constraints generated by the current path are more constraining
// than the constraints in the cache, in which case, the path is not worth
// following.
// The constraint cache is currently deeply tied to constraint-fpp and may not
// be useful otherwise.
//


//
// 
//

#ifndef __CONSTRAINT_CACHE_H__
#define __CONSTRAINT_CACHE_H__

#include "containers/list.hpp"
#include "arena/arena-vector.hpp" // arena_vector
#include "containers/hash_map.hpp"              // hash_map
#include "constraint/constraint.hpp"            // c_expr*
#include "ast/ast/cfg.hpp"                      // loop_iter_t
#include "caching.hpp"
#include "sm/sm.hpp"                            // sm_t
#include "subset-caching.hpp"                       // subset_cache_t etc.

// Threshold for maximum number of misses that a cache will allow
// This is required because loops can occasionally miss forever. 
extern int max_constraint_cache_misses, max_constraint_cache_loop_traversals,
    max_constraint_cache_matches;
extern bool enable_or_constraint_caching;


typedef hash_map_c_t<c_expr *, c_expr *, cast_hash<c_expr*>, equal_to<c_expr*> > c_expr_c_expr_map_t;

typedef map_c_t<c_expr *, std::list<c_expr *>, c_expr_lt_t> cexpr_cexprlist_t;
typedef hash_map<const char *, std::map<unsigned, unsigned>,
                 hash_cstr, eqstr> name_idxmap_map_t;


// The entry in the constraint cache has to contain the constraints along
// with the mapping to the latest indices of vars and uf's and the mapping
// to the last index of uf's of a particular name
class constraint_cache_entry_t {
public:
    constraint_cache_entry_t(arena_t *ar,
                             c_expr_c_expr_map_t *latest_var_uf_idx_map,
                             hash_map<const char *, unsigned, hash_cstr, eqstr> *uf_last_idx,
                             const VectorBase<c_expr *> &constraints,
                             loop_iter_t& li);

    // The maps are pointers to the actual maps in the backtrack stack
    // maintained within constraint-fpp. Those maps have been made to last
    // until the end of the function in order to make these pointers safe
    // to use
    c_expr_c_expr_map_t *latest_var_uf_idx;
    hash_map<const char *, unsigned, hash_cstr, eqstr> *uf_last_idx;
    arena_vector_t<c_expr *> constraints;

    loop_iter_t loop_iter;  // The loop iteration for this cache entry

    // Getter required because we need to extract the constraints for
    // backpatching as a list<c_expr *>
    const VectorBase<c_expr *> &get_constraints() const {
        return constraints;
    }

};

class constraint_cache_t : public cache_t
{
public:
    constraint_cache_t(arena_t *arena);
    
    ~constraint_cache_t();

    // Check if 'state' is already in the cache.
    virtual bool check_cache_hit(state_t* state,
                                 abstract_interp_t &cur_traversal,
                                 const cfg_edge_t *edge,
                                 bool widen,
                                 bool first_time);

    // Update the cache with the entry
    // NB: This is a cache that is different from the others (subset, 
    // equality, etc.) in that it can be updated EVEN (and sometimes ONLY)
    // when check_cache_hit is not called. This is counter-intuitive if you're
    // thinking of a classic cache, which updates itself only when there is
    // an access.
    // In constraint-fpp, we backpatch earlier caches in the path after we've
    // gone ahead
    void add_cache_entry(
        c_expr_c_expr_map_t *latest_var_uf_idx_map,
        hash_map<const char *, unsigned, hash_cstr, eqstr> *uf_last_idx,
        const VectorBase<c_expr *> &constraints,
        abstract_interp_t &cur_traversal,
        loop_iter_t& li);
  
    void clear_cache();

    arena_vector_t<constraint_cache_entry_t *>& get_entries() {
        return cache_entries;
    }

private:
    bool check_cache_hit_helper(state_t* sm_st, const cfg_edge_t *edge,
                                abstract_interp_t &cur_traversal);

    bool check_checker_hit_helper(sm_t* sm, abstract_interp_t &cur_traversal,
                                  loop_iter_t& loop_iter);

private:
    // The type/declaration of the cache data structure.
    // A vector of sets of c_exprs, where each set in the vector led to
    // a prune down some path following this cache point
    arena_vector_t<constraint_cache_entry_t *> cache_entries;
    
    typedef arena_set_t<
        loop_iter_t,
        loop_iter_lt> seen_iter_set_t;
    seen_iter_set_t seen_iters;

    typedef arena_map_t<
        loop_iter_t,
        subset_cache_pair_set_t *,
        loop_iter_lt
        > loop_iter_checker_state_map_t;
    loop_iter_checker_state_map_t loop_iter_checker_state_map;

    int num_misses;
};

#endif // ifndef __CONSTRAINT_CACHE_H__
